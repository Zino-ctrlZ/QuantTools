import numpy as np
from abc import ABCMeta, abstractmethod

from EventDriven.event import FillEvent, OrderEvent

# execution.py

class ExecutionHandler(object):
    """
    The ExecutionHandler abstract class handles the interaction
    between a set of order objects generated by a Portfolio and
    the ultimate set of Fill objects that actually occur in the
    market. 

    The handlers can be used to subclass simulated brokerages
    or live brokerages, with identical interfaces. This allows
    strategies to be backtested in a very similar manner to the
    live trading engine.
    """

    __metaclass__ = ABCMeta

    @abstractmethod
    def execute_order_naively(self, event):
        """
        Takes an Order event and executes it, producing
        a Fill event that gets placed onto the Events queue.

        Parameters:
        event - Contains an Event object with order information.
        """
        raise NotImplementedError("Should implement execute_order()")
    
    
class SimulatedExecutionHandler(ExecutionHandler):
    """
    The simulated execution handler simply converts all order
    objects into their equivalent fill objects automatically
    without latency, slippage or fill-ratio issues.

    This allows a straightforward "first go" test of any st
    rategy,
    before implementation with a more sophisticated execution
    handler.
    """
    
    def __init__(self, events, max_slippage_pct : float = 0.002, commission_rate : float = 0.00279):
        """
        Initialises the handler, setting the event queues
        up internally.

        Parameters:
        events - The Queue of Event objects.
        max_slippage_pct - The slippage range for the market default is 0.002
        commission_rate - The commission rate for the market default is 0.00279 per contract: https://robinhood.com/us/en/support/articles/trading-fees-on-robinhood/#Tradingactivityfee
        """
        self.events = events
        self.max_slippage_pct = max_slippage_pct
        self.commission_rate = commission_rate
        
    def execute_order_naively(self, event: OrderEvent):
        """
        Simply converts Order objects into Fill objects naively,
        i.e. without any latency, slippage or fill ratio problems.

        Parameters:
        event - Contains an Event object with order information.
        """

        ## Need to add market_value here
        if event.type == 'ORDER':
            fill_event = FillEvent(event.datetime, event.symbol,
                                   'ARCA', event.quantity, event.direction, fill_cost=0, commission=None, option=event.option)
            self.events.put(fill_event)
            
    def execute_order_randomized_slippage(self, event: OrderEvent):
        """
        This method will execute an order with a random slippage
        based on the max_slippage_pct attribute of the class.
        """
        assert event.type == 'ORDER', f"Event type must be 'ORDER' received {event.type}"
        assert event.direction == 'BUY' or event.direction == 'SELL', f"Event direction must be 'BUY' or 'SELL' received {event.direction}"
        commission = self.commission_rate * event.quantity * (len(event.position.get('trade_id', '&L:').split('&')) - 1) #commission is per trade(leg) there should always be a long in a position, naked or spread

        # Generate slippage as a percentage
        ## Slippage improvement
        if event.direction == 'BUY':
            ## We want to increase the price for buys by slippage
            slippage_pct = np.random.uniform(self.max_slippage_pct * 0.25, self.max_slippage_pct) ## Ensure that slippage is always positive, and never 0 or more than max_slippage_pct
        elif event.direction == 'SELL':
            ## We want to decrease the price for sells by slippage
            slippage_pct = np.random.uniform(-self.max_slippage_pct, -self.max_slippage_pct * 0.25)
        # slippage_pct = random.uniform(-self.max_slippage_pct, self.max_slippage_pct)
        
        #slippage may increase or decrease intended price
        price = event.position['close'] * (1 + slippage_pct)  
        market_value = (price * event.quantity) # cost before commission

        # Adjust price based on order direction
        if event.direction == 'BUY':
            fill_cost = market_value + commission
        elif event.direction == 'SELL':
            fill_cost = market_value - commission

        slippage_diff = (price - event.position['close'] ) * event.quantity
        fill_event = FillEvent(event.datetime, event.symbol, 'ARCA', event.quantity, event.direction, fill_cost=fill_cost, market_value=market_value, commission=commission, position=event.position, slippage=slippage_diff, signal_id=event.signal_id)
        self.events.put(fill_event)