# Event Driven Backtest

The `OptionSignalBacktest` class takes a trade dataframe, using the entry and exit time to form signals that get drip feed into handling trading processes of a traditional backtest. This backtest mechanism trades options using signals gotten from running stock backtesting strategies fed into the backtest class.

## Possible improvements

- Generating option can be its own event, that way the process can take on more complexity and modularity
- Fetching option data can be improved as ThetaData sometimes returns empty rows for options data
- The portfolio class can & should be imporved to allow for buying and selling different contracts of the same underlier
- Improve how contracts are picked, contracts with low to no volumen has 0 readings when retrieving ther data from ThetaData

### How to Use

- Run some backtest strategy that trades some underliers (eg PTBacktest)
- Get the trades dataframe
- Create an OptionSignalBacktest strategy and pass the trades dataframe
- call the run function
- after the backtest has run, you can run functions such as :
  - portfolio.get_trades() - to get data on the contracts traded during the period of the backtest
  - get_all_holdings() - to get data on all holdings and their value over the course f the backtest

### Summary of each module

Note: these summaries are AI generated

# Report on backtest.py

## Overview

The `backtest.py` file encapsulates the settings and components necessary for carrying out an event-driven backtest of an options trading strategy. It defines the `OptionSignalBacktest` class, which manages the setup and execution of the backtest by initializing the event queue, data handler, strategy, portfolio, execution handler, and logger.

## Classes

### `OptionSignalBacktest`

**Description**: Manages the setup and execution of an options trading strategy backtest. It integrates various components such as the data handler (`bars`), strategy (`strategy`), portfolio (`portfolio`), execution handler (`executor`), and event queue (`events`) to simulate trading in a backtesting environment.

#### `__init__` Method

- Initializes the backtest with the provided trade data and initial capital.
- **Parameters**:
  - `trades` (`pd.DataFrame`): A DataFrame containing trade data.
  - `initial_capital` (`int`): The starting capital for the backtest (default is 100,000).
- **Initializes**:
  - `events`: An event queue (`Queue`) for handling events.
  - `bars`: A `HistoricTradeDataHandler` instance for market data.
  - `strategy`: An `OptionSignalStrategy` instance for signal generation.
  - `portfolio`: An `OptionSignalPortfolio` instance for managing positions and holdings.
  - `executor`: A `SimulatedExecutionHandler` instance for simulating order execution.
  - `logger`: A logger for recording events and errors.
  - `risk_free_rate`: The risk-free interest rate used in calculations (set to 5.5%).

#### `run` Method

The `run` method contains the main event loop of the backtest, processing events generated by the data handler, strategy, portfolio, and execution handler.

**Summary**:

- **While Loop**:
  - Continues running until there is no more data to process (`self.bars.continue_backtest` is `False`).
  - Updates market data by calling `self.bars.update_bars()`.
  - Retrieves the latest bars with `self.bars.get_latest_bars('')`.
- **Event Processing Loop**:
  - Retrieves events from the event queue `self.events`.
  - Processes each event based on its `type`:
    - `'MARKET'`: The strategy calculates signals (`self.strategy.calculate_signals()`).
    - `'SIGNAL'`: The portfolio generates an order (`self.portfolio.generate_naive_option_order(event)`).
    - `'ORDER'`: The execution handler executes the order (`self.executor.execute_order(event)`).
    - `'FILL'`: The portfolio updates positions and holdings (`self.portfolio.update_fill(event)`).
    - Other types: Logs an error for unrecognized event types.
- **Exception Handling**:
  - Logs and prints exceptions that occur during event retrieval and processing.
- **Time Index Update**:
  - After processing events, the portfolio's time index is updated (`self.portfolio.update_timeindex()`).
- **Termination**:
  - When there is no more data, retrieves trades from the portfolio (`self.portfolio.get_trades()`), logs the completion, and exits the loop.

#### `get_all_holdings` Method

- Returns a DataFrame containing the portfolio's holdings over time.
- Sets the `'datetime'` column as the index.

#### `get_all_positions` Method

- Returns a DataFrame containing the portfolio's positions over time.
- Extracts option positions for each symbol.
- Sets the `'datetime'` column as the index.

## Summary

The `backtest.py` file provides a structured framework for executing an event-driven backtest of an options trading strategy. By managing the interaction between market data, signal generation, order execution, and portfolio management, it allows for the simulation and evaluation of trading algorithms in a controlled environment.

# Report on Classes and Functions in data.py

## Overview

The `data.py` file handles how market data is sourced and feeds the event loop. It defines an abstract base class `DataHandler` and several concrete implementations: `HistoricDataFrameDataHandler`, `HistoricCSVDataHandler`, and `HistoricTradeDataHandler`. These classes provide market data to the backtesting suite.

## Classes

### `DataHandler`

- **Description**: An abstract base class providing an interface for all subsequent data handlers (both live and historic). The goal is to output a generated set of bars (OHLCVI) for each requested symbol.
- **Methods**:
  - `get_latest_bars(self, symbol, N=1)`: Returns the last N bars from the latest symbol list, or fewer if less are available.
  - `update_bars(self)`: Pushes the latest bar to the latest symbol structure for all symbols in the symbol list.

### `HistoricDataFrameDataHandler`

- **Description**: Reads data from a MySQL database for each requested symbol and returns the latest bar of each symbol.
- **Constructor**:
  - `__init__(self, events, db_name, db_table, symbol_list)`: Initializes the historic data handler by requesting the latest bars from the database and setting up necessary structures.
- **Methods**:
  - `open_symbol_data(self)`: Queries the database for all entries based on the symbol list and returns a pandas DataFrame.
  - `_get_new_bar(self, symbol)`: Returns the latest bar from the data feed.
  - `get_latest_bars(self, symbol, N=1)`: Returns the last N bars from the latest symbol list.
  - `update_bars(self)`: Pushes the latest bar to the `latest_symbol_data` structure for all symbols.

### `HistoricCSVDataHandler`

- **Description**: Reads CSV files for each requested symbol from disk and provides an interface to obtain the "latest" bar in a manner identical to a live trading interface.
- **Constructor**:
  - `__init__(self, events, csv_dir, symbol_list)`: Initializes the historic data handler by specifying the location of the CSV files and a list of symbols.
- **Methods**:
  - `_open_convert_csv_files(self)`: Opens the CSV files from the data directory, converting them into pandas DataFrames.
  - `_get_new_bar(self, symbol)`: Returns the latest bar from the data feed as a tuple.
  - `get_latest_bars(self, symbol, N=1)`: Returns the last N bars from the latest symbol list.
  - `update_bars(self)`: Pushes the latest bar to the `latest_symbol_data` structure for all symbols.

### `HistoricTradeDataHandler`

- **Description**: Reads from a pandas DataFrame with trades data and converts that to signals of 1 (buy), -1 (sell), or 0 (do nothing).
- **Constructor**:
  - `__init__(self, events, trades_df)`: Initializes the historic trade data handler with the trades DataFrame.
- **Methods**:
  - `_open_trade_data(self)`: Opens the trade data and initializes the signal DataFrame.
  - `_get_new_bar(self)`: Returns the latest bar from the data feed.
  - `get_latest_bars(self, symbol='', N=1)`: Returns the last N bars from the latest signal list.
  - `update_bars(self)`: Pushes the latest bar to the `latest_signal_df` structure.
  - `update_options_data_on_order(self, contract)`: Updates the option data based on the fill contract.
  - `get_options_data(self, option_id)`: Returns a DataFrame with option data.
  - `get_option_id(self, contract)`: Returns a string identifier for the option.

## Functions and Imports

- **Imports**:
  - `load_dotenv`: Loads environment variables from a `.env` file.
  - `query_database`: Queries a MySQL database.
  - `retrieve_option_ohlc`: Retrieves OHLC data for options.
- **Utility Functions**:
  - Environment setup using `load_dotenv` and appending directories to `sys.path`.

## Summary

The `data.py` file provides a framework for sourcing and feeding market data into the event loop. The `DataHandler` class defines the interface, while `HistoricDataFrameDataHandler`, `HistoricCSVDataHandler`, and `HistoricTradeDataHandler` provide concrete implementations. These classes interact with various data sources to generate market data for backtesting purposes.

# Report on Classes and Functions in event.py

## Overview

The `event.py` file defines the core event classes used in the event-driven trading system. Events indicate changes in the state of the strategy, market, portfolio, or execution system. The file includes several event classes that inherit from a base `Event` class.

## Classes

### `Event`

- **Description**: An abstract base class providing an interface for all subsequent events that will trigger further actions in the trading infrastructure.

### `MarketEvent`

- **Description**: Handles the event of receiving a new market update with corresponding bars.
- **Constructor**:
  - `__init__(self)`: Initializes the `MarketEvent` and sets the event type to `'MARKET'`.
- **Attributes**:
  - `type`: A string indicating the event type (`'MARKET'`).

### `SignalEvent`

- **Description**: Handles the event of sending a signal from a strategy object. This is received by a portfolio object and acted upon.
- **Constructor**:
  - `__init__(self, symbol, datetime, signal_type)`: Initializes the `SignalEvent`.
    - `symbol`: The ticker symbol (e.g., `'GOOG'`).
    - `datetime`: The timestamp at which the signal was generated.
    - `signal_type`: The type of signal (`'LONG'` or `'SHORT'`).
- **Attributes**:
  - `type`: A string indicating the event type (`'SIGNAL'`).
  - `symbol`: The ticker symbol.
  - `datetime`: The timestamp of the signal.
  - `signal_type`: The signal type.

### `OrderEvent`

- **Description**: Handles the event of sending an order to an execution system. The order contains details such as the symbol, order type, quantity, direction, and optional option contract information.
- **Constructor**:
  - `__init__(self, symbol, datetime, order_type, quantity, direction, option=None)`: Initializes the `OrderEvent`.
    - `symbol`: The instrument to trade.
    - `datetime`: The timestamp when the order was generated.
    - `order_type`: `'MKT'` for Market or `'LMT'` for Limit order.
    - `quantity`: Non-negative integer for the quantity.
    - `direction`: `'BUY'` or `'SELL'`.
    - `option`: Optional. A pandas DataFrame with columns: root, expiration, strike, right (option type).
- **Methods**:
  - `print_order(self)`: Outputs the details of the order.
- **Attributes**:
  - `type`: A string indicating the event type (`'ORDER'`).
  - `symbol`, `datetime`, `order_type`, `quantity`, `direction`, `option`: As described above.

### `FillEvent`

- **Description**: Encapsulates the notion of a filled order as returned from a brokerage. Stores the filled quantity, fill cost, and any commission incurred.
- **Constructor**:
  - `__init__(self, datetime, symbol, exchange, quantity, direction, fill_cost, commission=None, option=None)`: Initializes the `FillEvent`.
    - `datetime`: The timestamp when the order was filled.
    - `symbol`: The instrument that was filled.
    - `exchange`: The exchange where the order was filled.
    - `quantity`: The filled quantity.
    - `direction`: `'BUY'` or `'SELL'`.
    - `fill_cost`: The cost of the fill.
    - `commission`: Optional. The commission for the trade.
    - `option`: Optional. Option contract information.
- **Methods**:
  - `calculate_ib_commission(self)`: Calculates the commission based on Interactive Brokers' fee structure.
- **Attributes**:
  - `type`: A string indicating the event type (`'FILL'`).
  - `symbol`, `datetime`, `exchange`, `quantity`, `direction`, `fill_cost`, `commission`, `option`: As described above.

## Summary

The `event.py` file provides essential classes that represent different types of events in the trading system. These events facilitate communication between components like data handlers, strategies, portfolios, and execution handlers. By standardizing event types, the system can handle complex interactions in an organized and efficient manner.

# Report on Classes and Functions in portfolio.py

## Overview

The `portfolio.py` file defines classes that handle portfolio management within an event-driven trading system. It provides an abstract base class `Portfolio` and a concrete implementation `OptionSignalPortfolio`. These classes are responsible for managing positions, generating orders based on signals, and updating holdings based on fills.

## Classes

### `Portfolio`

- **Description**: An abstract base class providing an interface for portfolio management. It defines methods that any portfolio class should implement.
- **Methods**:
  - `update_signal(self, event)`: Acts on a `SignalEvent` to generate new orders based on the portfolio logic.
  - `update_fill(self, event)`: Updates the portfolio's current positions and holdings from a `FillEvent`.

### `OptionSignalPortfolio`

- **Description**: A portfolio class designed to handle options trading. It generates orders based on signals and updates positions and holdings accordingly. It provides basic portfolio functionality without advanced risk management or position sizing.
- **Constructor**:
  - `__init__(self, bars, events, initial_capital=10000)`: Initializes the portfolio with a data handler (`bars`), event queue (`events`), and initial capital.
- **Methods**:
  - `construct_current_positions(self)`: Constructs the current positions dictionary based on the symbol list.
  - `construct_all_holdings(self)`: Constructs the holdings list using the start date.
  - `construct_all_positions(self)`: Constructs the positions list using the start date.
  - `construct_current_holdings(self)`: Constructs the current holdings dictionary.
  - `_generate_underlier_data(self)`: Initializes data for the underlying assets (stocks).
  - `generate_naive_option_order(self, signal)`: Generates an order based on a `SignalEvent` to buy or sell options.
  - `update_signal(self, event)`: Processes a `SignalEvent` to generate new orders.
  - `generate_option_to_buy(self, underlier, contract_fetch_attempts=0, invalid_contracts=[])`: Selects an option contract to buy based on the underlying asset.
  - `update_positions_from_fill(self, fill_event)`: Updates positions based on a `FillEvent`.
  - `update_holdings_from_fill(self, fill_event)`: Updates holdings based on a `FillEvent`.
  - `get_trades(self)`: Returns a DataFrame containing trade information.
  - `update_fill(self, event)`: Updates positions and holdings in response to a `FillEvent`.
  - `update_timeindex(self)`: Updates the time index for positions and holdings, reflecting current market data.
  - `create_equity_curve(self)`: Creates an equity curve based on the holdings.
  - `__get_latest_option_data(self, option_id)`: Retrieves the latest data for a specific option.
  - `get_options_data_on_contract(self, contract)`: Retrieves options data for a given contract.
  - `get_options_data(self, option_id)`: Returns options data for a given option ID.
  - `get_option_id(self, contract)`: Generates a unique ID for an option contract.
  - `__is_valid_dataframe(self, df)`: Checks if a DataFrame is valid (not empty or full of zeros).

## Imports and Dependencies

- **Standard Libraries**:
  - `typing`: For type hinting and annotations.
  - `os`, `sys`: For operating system and system-specific parameters and functions.
  - `pandas`: For data manipulation and analysis.
  - `copy`: For copying objects.
- **Third-Party Libraries**:
  - `dotenv`: To load environment variables from a `.env` file.
- **Custom Modules**:
  - `dbase.DataAPI.ThetaData`: For data retrieval functions like `list_contracts` and `retrieve_option_ohlc`.
  - `trade.assets.Stock`: Represents an underlying stock asset.
  - `trade.helpers.Logging`: For setting up logging.
  - Event classes: `FillEvent`, `OrderEvent`, `SignalEvent` from `event.py`.
  - Data handler: `HistoricTradeDataHandler` from `data.py`.

## Summary

The `portfolio.py` file provides classes for managing trading portfolios within an event-driven trading system. The `Portfolio` abstract base class defines the required interface, while `OptionSignalPortfolio` implements functionality for handling options trading, including generating orders, updating positions and holdings, and tracking trades. It serves as a foundational component for portfolio management in a backtesting or live trading environment.

# Report on Classes and Functions in strategy.py

## Overview

The `strategy.py` file defines the structure and behavior of trading strategies. It includes an abstract base class `Strategy` and two concrete implementations: `BuyAndHoldStrategy` and `OptionSignalStrategy`. These classes are designed to generate trading signals based on market data.

## Classes

### `Strategy`

- **Description**: An abstract base class providing an interface for all subsequent strategy handling objects.
- **Methods**:
  - `calculate_signals(self)`: An abstract method that must be implemented by derived classes to calculate trading signals.

### `BuyAndHoldStrategy`

- **Description**: A simple strategy that goes LONG on all symbols as soon as a bar is received and never exits a position. It serves as a testing mechanism and a benchmark for other strategies.
- **Constructor**:
  - `__init__(self, bars, events)`: Initializes the strategy with a `DataHandler` object (`bars`) and an event queue (`events`).
- **Methods**:
  - `_calculate_initial_bought(self)`: Initializes a dictionary to track whether a buy signal has been issued for each symbol.
  - `calculate_signals(self, event)`: Generates a single LONG signal per symbol when a market event is received.

### `OptionSignalStrategy`

- **Description**: A strategy that generates signals to buy or sell options based on data from the data handler.
- **Constructor**:
  - `__init__(self, bars, events)`: Initializes the strategy with a `DataHandler` object (`bars`), an event queue (`events`), and sets up logging.
- **Methods**:
  - `_generate_underlier_data(self)`: Initializes a dictionary to store `Stock` objects for each symbol.
  - `calculate_signals(self)`: Reads the latest signals from the data handler and generates buy or sell signals for options based on the data.

## Functions

### `setup_logger`

- **Description**: Sets up a logger for the `OptionSignalStrategy` class.
- **Usage**: Called within the `OptionSignalStrategy` constructor to initialize logging.

### `SignalEvent`

- **Description**: Represents a signal event in the trading system.
- **Usage**: Instances of `SignalEvent` are created and added to the event queue when a trading signal is generated.
