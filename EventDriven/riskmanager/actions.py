"""Risk Manager Action Types and Event Definitions.

This module defines the action classes that represent risk manager decisions and
recommendations for position management. Each action type corresponds to a specific
event that can be triggered based on position analysis, risk limits, or strategy rules.

Action Types:
    HOLD: Maintain current position without changes
        - Default action when no risk limits breached
        - No quantity or position modifications
        - Includes reason tracking for audit trail

    CLOSE: Exit position completely
        - Triggered by risk limit violations, signal exit, or profit targets
        - Closes all legs of complex structures
        - Captures closing reason for post-analysis

    ROLL: Replace current position with new one
        - Used when DTE reaches minimum threshold
        - Allows optional quantity adjustment during roll
        - Maintains strategy exposure while refreshing time value

    ADJUST: Modify position quantity without closing
        - Scale up/down based on conviction or risk changes
        - Requires quantity_diff in action parameter
        - Useful for dynamic position sizing

    EXERCISE: Exercise in-the-money options
        - Typically at expiration or for dividend capture
        - Converts option position to stock position
        - Handles assignment scenarios

Action Attributes:
    Common to all action types:
        - trade_id: Unique identifier for the position
        - action: Action-specific parameters (dict or string)
        - type: EventTypes enum value
        - name: String representation of action
        - reason: Explanation for the action decision
        - analysis_date: When decision was made
        - effective_date: When action should be executed
        - verbose_info: Additional debugging information

Changes TypedDict:
    Structure for quantity modifications:
        - quantity_diff: Change in contracts (positive or negative)
        - new_quantity: Target quantity after change

Usage:
    # Create a roll action with quantity increase
    roll_action = ROLL(
        trade_id='AAPL_20240115_175P',
        action={'quantity_diff': 2, 'new_quantity': 12}
    )
    roll_action.reason = 'DTE below 21 days threshold'
    roll_action.analysis_date = datetime(2024, 1, 10)

    # Create a close action
    close_action = CLOSE(trade_id='MSFT_20240220_350C')
    close_action.reason = 'Delta limit exceeded'

Integration:
    - Actions generated by PositionAnalyzer cogs
    - Consumed by RiskManager for execution
    - Logged in trade ledger for audit trail
    - Used in performance attribution analysis

Notes:
    - All actions inherit from RMAction base class
    - Action priority determined by ACTION_PRIORITY mapping
    - Multiple actions per position resolved by priority
    - Reason field critical for understanding strategy behavior
"""

## Actions classes
from datetime import datetime
from EventDriven.types import EventTypes
from typing_extensions import TypedDict, Union


class Changes(TypedDict):
    quantity_diff: int
    new_quantity: int


action_hint = Union[str, Changes]


class RMAction:
    def __init__(self, trade_id: str, action: action_hint = None):
        self.trade_id = trade_id
        self.action = action if action is not None else {}
        self.type: EventTypes = None
        self.name: str = None
        self.reason: str = None
        self.event: EventTypes = None
        self.analysis_date: datetime | str = None
        self.effective_date: datetime | str = None
        self.verbose_info: str = None


class HOLD(RMAction):
    def __init__(self, trade_id: str, action: action_hint = None):
        super().__init__(trade_id, action)
        self.name = EventTypes.HOLD.value
        self.reason = None
        self.type = EventTypes("HOLD")

    def __repr__(self):
        return f"HOLD({self.trade_id}) Reason: {self.reason})"


class CLOSE(RMAction):
    def __init__(self, trade_id: str, action: action_hint = None):
        super().__init__(trade_id, action)
        self.name = EventTypes.CLOSE.value
        self.type = EventTypes("CLOSE")
        self.reason = None

    def __repr__(self):
        return f"CLOSE({self.trade_id}), Reason: {self.reason})"


class ROLL(RMAction):
    def __init__(self, trade_id: str, action: action_hint = None):
        super().__init__(trade_id, action)
        self.name = EventTypes.ROLL.value
        self.type = EventTypes("ROLL")
        self.reason = None
        self.quantity_change = action.get("quantity_diff", None)

    def __repr__(self):
        return f"ROLL({self.trade_id}, Quantity Change: {self.quantity_change}), Reason: {self.reason})"


class ADJUST(RMAction):
    def __init__(self, trade_id: str, action: action_hint = None):
        super().__init__(trade_id, action)
        self.quantity_change = action["quantity_diff"]
        self.name = EventTypes.ADJUST.value
        self.type = EventTypes("ADJUST")
        self.reason = None

    def __repr__(self):
        return f'ADJUST({self.trade_id}, Quantity Change: {self.action["quantity_diff"]}), Reason: {self.reason})'


class EXERCISE(RMAction):
    def __init__(self, trade_id: str, action: action_hint = None):
        super().__init__(trade_id, action)
        self.name = EventTypes.EXERCISE.value
        self.type = EventTypes("EXERCISE")
        self.reason = None

    def __repr__(self):
        return f"EXERCISE({self.trade_id}, Reason: {self.reason})"
